import shadow:natives;

/**
 * Class {@code Mailbox} is the main component of the Message Passing
 * between Threads in the Shadow language. 
 *
 * @seeDoc shadow:standard@Thread
 * @author Claude Abounegm
 */
locked class shadow:standard@
	Mailbox
{
	// this shouldn't be for too long; best time for it?
	readonly TimeSpan TIMEOUT = Time.fromMilliSeconds(5000);
	
	//private extern $interrupt(Thread instance, boolean shouldThrow) => (boolean);
	
	/*
	* NOTES
	*
	* Note1: We would like to notify all the waiting threads 
	*        that something happened whenever we enqueue or dequeue. 
	*        If the change that happened is not beneficial to those waiting
	*        threads, they will go right back to sleep until another change 
	*        happens or until they timeout. This avoids us busy waiting.
	*/
	
	Signaler signaler;
	MessageQueue list;
	Mutex mutex;
	
	/**
	* Initializes a {@code Mailbox} with a backing array that has {@code min} items space to start with
	* and can expand up to {@code max}.
	*/
	public create(int min, int max)
	{
		this:list = MessageQueue:create(min, max);
		this:signaler = Signaler:create();
		this:mutex = Mutex:create();
	}	
	
	/**
	* Initializes a {@code Mailbox} with a backing array with an initial and maximum capacity of {@code size}.
	*/
	public create(int size)
	{
		this(size, size);
	}
	
	/**
	* @throws FullMailboxException
	* @throws InterruptedException
	*/
	public sendTo(Object data, boolean blocking) => ()
	{
		CurrentThread.throwIfInterrupting();
		
		var message = Message:create(data);
		if(!blocking) {
			throw (!list.enqueue(message)) ? FullMailboxException:create();
		} else {
			var stop = false;
			while(!stop) {
				stop = list.enqueue(message);
				
				if(!stop) {
					signaler.waitForNotify(TIMEOUT);
				}
			}
		}
		
		signaler.notifyAll();
	}
	
	/**
	* @throws EmptyMailboxException
	* @throws InterruptedException
	*/
	public receiveFirst(Class expectedType, boolean blocking) => (Object, Thread)
	{
		CurrentThread.throwIfInterrupting();

		nullable var message = list.dequeue(expectedType);
		if(!blocking) {
			throw (message === null) ? EmptyMailboxException:create();
		} else {
			while(message === null) {
				message = list.dequeue(expectedType);
				
				if(message === null) {
					signaler.waitForNotify(TIMEOUT);
				}
			}
		}
		
		signaler.notifyAll();
		
		return (check(message)->data, check(message)->sender);
	}
	
	/**
	* @throws EmptyMailboxException
	* @throws InterruptedException
	*/
	public receiveFirstFrom(Class expectedType, Thread sender, boolean blocking) => (Object)
	{
		CurrentThread.throwIfInterrupting();

		nullable var message = list.dequeue(sender, expectedType);
		if(!blocking) {
			throw (message === null) ? EmptyMailboxException:create();
		} else {
			while(message === null) {
				message = list.dequeue(sender, expectedType);
				
				if(message === null) {
					signaler.waitForNotify(TIMEOUT);
				}
			}
		}
		
		signaler.notifyAll();

		return (check(message)->data);
	}
	
	public sendTo(Object data) => ()
	{
		sendTo(data, true);
	}
	
	public receiveFirst(Class expectedType) => (Object, Thread)
	{
		return receiveFirst(expectedType, true);
	}
	
	public receiveFirstFrom(Class expectedType, Thread sender) => (Object)
	{
		return receiveFirstFrom(expectedType, sender, true);
	}
}