/**
 * Class {@code Mutex} is an implementation of Mutual-Exclusion in Shadow. This implementation
 * allows nested locks, which can be useful in some scenarios, such as with recursive methods.
 *
 * @author Claude Abounegm
 *
 * @seeDoc shadow:test@MutexTest
 *
 * @seeDoc shadow:natives@Signaler
 * @seeDoc shadow:standard@Thread
 * @seeDoc shadow:standard@Mailbox
 */
locked immutable class shadow:natives@
	Mutex
{
	private readonly extern __ShadowMutex_Initialize(boolean allowRecursive) => (ShadowPointer);
	private readonly extern __ShadowMutex_Destroy(ShadowPointer ptr) => (boolean);
	private readonly extern __ShadowMutex_Lock(ShadowPointer ptr, Thread currentThread) => (boolean);
	private readonly extern __ShadowMutex_Unlock(ShadowPointer ptr) => (boolean);
	private readonly extern __ShadowMutex_GetOwner(ShadowPointer ptr) => (nullable Thread);
	
	ShadowPointer ptr;
	
	/**
	* Initializes a new {@code Mutex} which does not allow nested locks.
	*/
	public create()
	{
		this(false);
	}
	
	/**
	* Initializes a new {@code Mutex} which can allow nested locks.
	* @param allowRecursiveLocks whether the Mutex should allow mutliple nested locks.
	*/
	public create(boolean allowRecursiveLocks)
	{
		ptr = __ShadowMutex_Initialize(allowRecursiveLocks);
		
		if(!ptr->isValid) {
			throw MutexException:create("An error occured while initializing the Mutex.");
		}
	}
	
	/**
	* Attempts to lock this Mutex. If the Mutex is already owned by another thread, this method
	* blocks until the Mutex becomes available. If the current thread already owns this mutex and
	* recursive locks are allowed, this method will simply increase the counter. The mutex should be unlocked
	* the same number of times it was locked.
	*
	* @throws MutexException if recursive locks are not allowed and the mutex is already owned by this thread.
	* @throws FreedResourceException if the Mutex has been freed.
	*/
	public lock() => ()
	{
		ptr.assertValid("Mutex");

		if(!__ShadowMutex_Lock(ptr, CurrentThread->instance)) {
			throw MutexException:create("This mutex does not allow recursive locks.");
		}
	}
	
	/**
	* Attempts to unlock this Mutex. If the Mutex has been locked mutliple times by this thread,
	* this method simply decreases the counter. This Mutex is unlocked when an corresponding unlock has been called
	* for each lock. i.e. If {@code lock()} was called twice, {@code unlock()} will unlock the mutex on
	* its second call.
	*
	* @throws MutexException if this Mutex is not owned by this thread.
	* @throws FreedResourceException if the Mutex has been freed.
	*/
	public unlock() => ()
	{
		ptr.assertValid("Mutex");
		
		if(!isOwnerCurrentThread()) {
			throw MutexException:create("This mutex is not owned by '" # CurrentThread->name # "' and cannot be unlocked." # (owner() === null ? "", #owner()));
		}
		
		__ShadowMutex_Unlock(ptr);
		// TODO: error checking
	}
	
	/**
	* Frees the resources allocated by this {@code Mutex}.
	*
	* @throws MutexException if the Mutex is locked by another thread.
	*/
	public free() => ()
	{
		if(ptr->isValid) {
			if(isOwnerCurrentThread()) {
				unlock();
			} else if(owner() !== null) {
				throw MutexException:create("Cannot free a locked Mutex.");
			}
			
			__ShadowMutex_Destroy(ptr);
			ptr.free();
		}
	}
	
	private owner() => (nullable Thread)
	{
		return __ShadowMutex_GetOwner(ptr);
	}
	
	private isOwnerCurrentThread() => (boolean)
	{
		return CurrentThread.equal(owner());
	}
}